
/*
 ***************************************************************************
 *                  Mica - the Java(tm) Graphics Framework                 *
 ***************************************************************************
 * NOTICE: Permission to use, copy, and modify this software and its       *
 * documentation is hereby granted provided that this notice appears in    *
 * all copies.                                                             *
 *                                                                         *
 * Permission to distribute un-modified copies of this software and its    *
 * documentation is hereby granted provided that no fee is charged and     *
 * that this notice appears in all copies.                                 *
 *                                                                         *
 * SOFTWARE FARM MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE          *
 * SUITABILITY OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT  *
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR  *
 * A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. SOFTWARE FARM SHALL NOT BE   *
 * LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR       *
 * CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE, MODIFICATION OR           *
 * DISTRIBUTION OF THIS SOFTWARE OR ITS DERIVATIVES.                       *
 *                                                                         *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND      *
 * DISTRIBUTORS HAVE NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT,        *
 * UPDATES, ENHANCEMENTS, OR MODIFICATIONS.                                *
 *                                                                         *
 ***************************************************************************
 *   Copyright (c) 1997-2004 Software Farm, Inc.  All Rights Reserved.     *
 ***************************************************************************
 */


package com.swfm.mica;

import java.io.*;
import java.util.Stack;
import com.swfm.mica.util.Strings;
import com.swfm.mica.util.Utility;
import com.swfm.mica.util.IntVector;

/*
	Convert PrintStream to PrintWriter for non-deprecated 1.1+ compatbility.
*/

/**----------------------------------------------------------------------------------------------
 * This class provides debug support. The most common usages is to call MiDebug#println,
 * which will send a message to both STDOUT and the (optional) log file, and 
 * MiDebug.printStackTrace() which sends the stack trace to both STDOUT and the (optional) 
 * log file.
 * <p>
 * To see the size of the bounds and drawBounds of a MiPart, drawn as
 * green and yellow rectangles, respectively, you can do the following:
 * <p>
 *	part.setAfterRenderer(new MiBoundsRenderer());
 * <p>
 * To trace when an action is generated by a part (for example to see whenever
 * a icon is moved or resized:
 * <p>
 *	MiDebug.traceActions(myIcon, MiiActionTypes.Mi_GEOMETRY_CHANGE_ACTION,
 *	MiDebug.Mi_LOG_PRINT_CHANGE_EVENT | MiDebug.Mi_LOG_PRINT_STACK | MiDebug.Mi_LOG_PRINT_BOUNDS);
 * <p>
 * or for this particular example:
 * <p>
 * 	MiDebug.traceGeometricActions(myIcon);
 * <p>
 * @version     %I% %G%
 * @author      Michael L. Davis
 * @release 	1.4.1
 * @module 	%M%
 * @language	Java (JDK 1.4)
 *----------------------------------------------------------------------------------------------*/
public class MiDebug 
	{
	public static final int		TRACE_SHORT_CUT_DISPATCHING	= (1 << 0);
	public static final int		TRACE_DRAWING_OF_PARTS		= (1 << 1);
	public static final int		TRACE_DRAWING_OF_ATTACHMENTS	= (1 << 2);
	public static final int		TRACE_KEYBOARD_FOCUS_DISPATCHING= (1 << 3);
	public static final int		TRACE_DRAG_AND_DROP		= (1 << 4);
	public static final int		TRACE_WINDOW_AND_CANVAS_RESIZING= (1 << 5);
	public static final int		TRACE_CANVAS_DRAW_TIMES		= (1 << 6);
	public static final int		TRACE_DOUBLE_BUFFER_RENDERING	= (1 << 7);
	public static final int		TRACE_EVENT_DISPATCHING		= (1 << 8);
	public static final int		TRACE_EVENT_HANDLER_GRABS	= (1 << 9);
	public static final int		TRACE_EVENT_INPUT		= (1 << 10);
	public static final int		TRACE_AREA_INVALIDATION		= (1 << 11);
	public static final int		TRACE_EVENT_TO_COMMAND_TRANSLATION= (1 << 12);
	public static final int		TRACE_INTERACTIVE_SELECT	= (1 << 13);
	public static final int		TRACE_CUSTOM_DEBUG_INFO		= (1 << 14);
	public static final int		TRACE_BASIC_ALLOCATIONS		= (1 << 15);
	public static final int		TRACE_MODEL_CHANGE_EVENTS	= (1 << 16);

	public static 	boolean		debug				= true;
	public static 	boolean		localDebug			= false;
	public static 	boolean		checkForLingeringInvalidLayoutsBelow = true;
	public static 	int		traceMode			= 0;
	public static 	int		traceIterations			= -1;
	public static 	String[]	traceClasses;
	public static	boolean		printValidationErrors		= false;

	private static final String	MICA_NAME			= "MICA: ";
	private  static	Stack		stack				= new Stack();
	private	 static	PrintStream[]	files				= new PrintStream[0];
	private	 static	String		indent				= new String();
	private	 static	int		numberOfErrors 			= 0;
	private	 static	int		depth	 			= 0;
	private	 static	Strings		logOutputBuffer			= null;
	private	 static	boolean		loggingToFile			= false;
	private	 static	boolean		loggingToStdOut			= true;
	private	 static	boolean		loggingToBuffer			= false;
	private	 static	boolean		loggingMethodEntersAndExits	= false;
	private	 static	boolean		loggingTraces			= false;
	private	 static	boolean		loggingErrors			= true;
	private	 static	boolean		micaPrefixEnabled		= true;
	private	 static	MiDumpGraphicsStructures		printStruct;
	private	 static	MiDebugActionHandler 			changeEventHandler;
	private	 static	MiDebugModelModelChangeHandler 		modelModelChangeHandler;


	public static	void		setLoggingFilename(String name) throws Exception
		{
		for (int i = 0; i < files.length; ++i)
			{
			files[i].close();
			}
		if (name != null)
			{
			files = new PrintStream[1];
			PrintStream file = new PrintStream(MiSystem.getIOManager().getOutputResourceAsStream(name));
			files[0] = file;
			loggingToFile = true;
			}
		else
			{
			files = new PrintStream[0];
			loggingToFile = false;
			}
		}
	public static	void		addLoggingFilename(String name) throws Exception
		{
		PrintStream[] newFiles = new PrintStream[files.length + 1];
		for (int i = 0; i < files.length; ++i)
			{
			newFiles[i] = files[i];
			}
		newFiles[files.length] = new PrintStream(MiSystem.getIOManager().getOutputResourceAsStream(name));
		loggingToFile = true;
		}
	public	static	int		getNumberOfLoggingPrintStreams()
		{
		return(files.length);
		}
	public	static	PrintStream	getLoggingPrintStream(int index)
		{
		return(files[index]);
		}
	public	static	void		setLoggingPrintStream(PrintStream stream)
		{
		for (int i = 0; i < files.length; ++i)
			{
			files[i].close();
			}
		if (stream != null)
			{
			files = new PrintStream[1];
			files[0] = stream;
			loggingToFile = true;
			}
		else
			{
			files = new PrintStream[0];
			loggingToFile = false;
			}
		}
	public	static	void		addLoggingPrintStream(PrintStream stream)
		{
		PrintStream[] newFiles = new PrintStream[files.length + 1];
		for (int i = 0; i < files.length; ++i)
			{
			newFiles[i] = files[i];
			}
		newFiles[files.length] = stream;
		files = newFiles;
		loggingToFile = true;
		}

	public static	void		getMemoryStatistics(long[] freeMemory, long[] totalMemory, boolean doGarbageCollection)
		{
		Runtime runtime = Runtime.getRuntime();
		if (doGarbageCollection)
			{
			runtime.runFinalization();
			runtime.gc();
			}
		freeMemory[0] = runtime.freeMemory();
		totalMemory[0] = runtime.totalMemory();
		}
	public static	void		getMemoryStatistics(long[] freeMemory, long[] totalMemory)
		{
		getMemoryStatistics(freeMemory, totalMemory, true);
		}

	public static	void		printMemoryReport()
		{
		Runtime runtime = Runtime.getRuntime();
		runtime.runFinalization();
		runtime.gc();
		logMessages("Memory report: free = " + runtime.freeMemory() + " total = " + runtime.totalMemory());
		}

	public static	void		setTraceMode(int mask)
		{
		traceMode = mask;
		}
	public static	int		getTraceMode()
		{
		return(traceMode);
		}

	public static	void		setTraceClasses(String[] classNames)
		{
		traceClasses = classNames;
		}
	public static	String[]	getTraceClasses()
		{
		return(traceClasses);
		}

	public static	void		setTraceIterations(int numberOfIterations)
		{
		traceIterations = numberOfIterations;
		}
	public static	int		getTraceIterations()
		{
		return(traceIterations);
		}

	public static	boolean		isTracing(MiPart part, int tracingMode)
		{
		if ((traceIterations == 0) || ((traceMode & tracingMode) == 0))
			return(false);

		--traceIterations;

		if ((traceClasses != null) && (part != null))
			{
			String partClassName = part.getClass().getName();
			for (int i = 0; i < traceClasses.length; ++i)
				{
				if (partClassName.equals(traceClasses[i]))
					return(true);
				}
			return(false);
			}
		return(true);
		}

	public static	void		showBoundingBox(MiPart target)
		{
		MiRectangle rect = new MiRectangle();
		rect.setColor("red");
		target.appendAttachment(rect, MiiTypes.Mi_SURROUND_LOCATION, "MiDebug.showBoundingBox", null);
		}
	public static	void		removeBoundingBox(MiPart target)
		{
		target.removeAttachment("MiDebug.showBoundingBox");
		}
	public static	String		getMicaClassName(Object obj)
		{
		String name = obj.getClass().getName();
		if (name.startsWith("com.swfm.mica."))
			name = name.substring("com.swfm.mica.".length());
		return(name);
		}

	public static	void		dumpStructureOnly(MiPart obj)
		{
		if (obj == null)
			println("<null>");
		if (printStruct == null)
			printStruct = new MiDumpGraphicsStructures();
		printStruct.setTargetOfCommand(obj);
		printStruct.processCommand(MiDumpGraphicsStructures.STRUCTURE_INFO_ONLY);
		}
	public static	void		dump(MiPart obj)
		{
		if (obj == null)
			println("<null>");
		if (printStruct == null)
			printStruct = new MiDumpGraphicsStructures();
		printStruct.setTargetOfCommand(obj);
		printStruct.processCommand(null);
		}
	public static	void		dump(MiiModelEntity obj)
		{
		if (obj == null)
			println("<null>");
		println(MiModelEntity.dump(obj));
		}
	public static	void		dumpPart(MiPart obj)
		{
		if (obj == null)
			println("<null>");
		if (printStruct == null)
			printStruct = new MiDumpGraphicsStructures();
		printStruct.setTargetOfCommand(obj);
		printStruct.processCommand(MiDumpGraphicsStructures.DETAILED_INFO_BUT_NOT_CONTENTS);
		}

	public static	void		sleep(long microSeconds)
		{
		try	{
			Thread.sleep(microSeconds);
			}
		catch (InterruptedException e)
			{
			}
		}
					// raiseNullPointerException
	public static	void		halt()
		{
		halt("Debugging halt");
		}
	public static	void		halt(String msg)
		{
		logError("Manually halting execution because: " + msg);
		printStackTrace("Manually halting execution because: " + msg);
		Thread.currentThread().stop();
		}
	public static	void		where()
		{
		_printStackTrace("*******************************\n*   FOR DEBUG PURPOSES ONLY   *\n*******************************");
		}
	public static	void		printAllThreads()
		{
		Thread thread = Thread.currentThread();
		ThreadGroup threadGroup = thread.getThreadGroup();
		int numGroups = threadGroup.activeGroupCount();
		ThreadGroup[] threadGroups = new ThreadGroup[numGroups];
		threadGroup.enumerate(threadGroups);
		for (int i = 0; i < threadGroups.length; ++i)
			{
			ThreadGroup group = threadGroups[i];
			int numThreads = group.activeCount();
			Thread[] threads = new Thread[numThreads];
			group.enumerate(threads);
			for (int j = 0; j < threads.length; ++j)
				{
				println(threads[i].toString());
				}
			}
		}
	public static	String		getStackTrace(Throwable e)
		{
		ByteArrayOutputStream exceptionMessage = new ByteArrayOutputStream();
		PrintStream exceptionPrintStream = new PrintStream(exceptionMessage);
		e.printStackTrace(exceptionPrintStream);
		return(exceptionMessage.toString());
		}
	public static	void		printStackTrace(Throwable e)
		{
		logMessages(getStackTrace(e));
		}
	public static	void		printStackTrace()
		{
		_printStackTrace("*******************************\n*   FOR DEBUG PURPOSES ONLY   *\n*******************************");
		}
	public static	void		printStackTrace(String msg)
		{
		_printStackTrace(
			"*******************************\n*   FOR DEBUG PURPOSES ONLY   *\n"
			+ "*   " + msg 
			+ "\n*******************************");
		}
	private static	void		_printStackTrace(String msg)
		{
		logTrace("Manually printing stack for event: " + msg);
		logMessages(msg);
		if (loggingToFile)
			{
			for (int i = 0; i < files.length; ++i)
				{
		        	new Exception().printStackTrace(files[i]);
				}
			}
		Thread.dumpStack();
		}

	public static 	void		enter(String traceMsg)
		{
		if (loggingMethodEntersAndExits)
			{
			logMethod("Enter: " + traceMsg);
			stack.push(new String(traceMsg));
			}
		++depth;
		calcIndent();
		}
	public static 	void		trace(String traceMsg)
		{
		logTrace(traceMsg);
		}
	public static 	void		priority(String traceMsg)
		{
		logMessages(traceMsg);
		}
	public static 	void		printlnError(String errorMsg)
		{
		++numberOfErrors;
		logError(errorMsg);
		}
	public static 	void		exit()
		{
		if (depth > 0)
			{
			--depth;
			calcIndent();
			if (loggingMethodEntersAndExits)
				logMethod("Exit:  " + (String )stack.pop());
			}
		}

	public static	void		startFullTrace()
		{
		// Runtime.getRuntime().traceMethodCalls(true);
		}
	public static	void		stopFullTrace()
		{
		// Runtime.getRuntime().traceMethodCalls(false);
		}

	public static	void		clearNumberOfErrors()
		{
		numberOfErrors = 0;
		}
	public static	int		getNumberOfErrors()
		{
		return(numberOfErrors);
		}

	public static	void		enterAndClearNumberOfErrors(String traceMsg)
		{
		enter(traceMsg);
		clearNumberOfErrors();
		}

	public static	int		exitAndReturnNumberOfErrors()
		{
		exit();
		return(getNumberOfErrors());
		}

	private static	void 		logMethod(String msg)
		{
		if (loggingMethodEntersAndExits)
			logMessages(msg);
		}
	private static	void 		logTrace(String msg)
		{
		if (loggingTraces)
			logMessages(msg);
		}
	private static	void 		logError(String msg)
		{
		if (loggingErrors)
			{
			logMessages("*************** ERROR *****************");
			logMessages(msg);
			logMessages("*************** ERROR *****************");
			}
		}
	private static	void		setLoggingToStdOut(boolean flag)
		{
		loggingToStdOut = flag;
		}
	private static	boolean		getLoggingToStdOut()
		{
		return(loggingToStdOut);
		}
	private static	void		setLoggingToFile(boolean flag)
		{
		loggingToFile = flag;
		}
	private static	boolean		getLoggingToFile()
		{
		return(loggingToFile);
		}
	private static	void		setLoggingToBuffer(boolean flag)
		{
		loggingToBuffer = flag;
		}
	private static	boolean		getLoggingToBuffer()
		{
		return(loggingToBuffer);
		}
	private	static	void		setLoggingBuffer(Strings buffer)
		{
		logOutputBuffer = buffer;
		}
	private	static	Strings		getLoggingBuffer()
		{
		return(logOutputBuffer);
		}
	private	static	void		logMessages(String msg)
		{
		if (loggingToStdOut)
			{
			System.out.println(indent + msg);
			System.out.flush();
			}
		if (loggingToFile)
			{
			for (int i = 0; i < files.length; ++i)
				{
				files[i].println(indent + msg);
				files[i].flush();
				}
			}
		if (loggingToBuffer)
			{
			logOutputBuffer.addElement(indent + msg);
			}
		}
	public static	void		printHex(int val)
		{
//		logMessages(Integer.toHexString(val));
		logMessages(Utility.toHexString(val));
		}

	public static	void		setMicaPrefixEnabled(boolean flag)
		{
		micaPrefixEnabled = flag;
		}
	public static	boolean		getMicaPrefixEnabled()
		{
		return(micaPrefixEnabled);
		}
	public static	void		println(String str)
		{
		if (micaPrefixEnabled)
			logMessages(MICA_NAME + str);
		else
			logMessages(str);
//new Exception().printStackTrace(); // Used to find out just WHO is printing out debug messages
		}
	public static	void		println(Object obj)
		{
		if (micaPrefixEnabled)
			logMessages(MICA_NAME + obj.toString());
		else
			logMessages(obj.toString());
		}
	public static	void		print(String str)
		{
		if (loggingToStdOut)
			{
			System.out.print(indent + str);
			System.out.flush();
			}
		if (loggingToFile)
			{
			for (int i = 0; i < files.length; ++i)
				{
				files[i].print(indent + str);
				}
			}
		}
	private static	void 		calcIndent()
		{
		if (!loggingMethodEntersAndExits)
			return;

		int num = depth;
		indent = new String("   ");
		while (num > 0)
			{
			indent = indent.concat(" | ");
			--num;
			}
		}
	public static	void		delay(long count)
		{
		while (count-- > 0)
			;
		}

	public static	MiPart		getPartWithInvalidArea(MiPart container)
		{
		if (!container.getThisOrPartHasInvalidArea())
			{
			return(null);
			}
		for (int i = 0; i < container.getNumberOfParts(); ++i)
			{
			MiPart part = container.getPart(i);
			if (part.getThisOrPartHasInvalidArea())
				{
				MiPart child = getPartWithInvalidArea(part);
				if (child != null)
					{
					return(child);
					}
				return(part);
				}
			MiPart child = getPartWithInvalidArea(part);
			if (child != null)
				{
				return(child);
				}
			}
		return(container);
		}

	public static final int	Mi_LOG_PRINT_CHANGE_EVENT	= 1 << 0;
	public static final int	Mi_LOG_PRINT_STACK		= 1 << 1;
	public static final int	Mi_LOG_PRINT_BOUNDS		= 1 << 2;
	public static final int	Mi_LOG_DUMP_SUBJECT		= 1 << 3;
	public static final int	Mi_LOG_DUMP_TARGET		= 1 << 4;

//-------------------------------------------------------------
//	MiDebug.traceActions(hScrollBar, MiiActionTypes.Mi_GEOMETRY_CHANGE_ACTION,
//	MiDebug.Mi_LOG_PRINT_CHANGE_EVENT | MiDebug.Mi_LOG_PRINT_STACK | MiDebug.Mi_LOG_PRINT_BOUNDS);
//-------------------------------------------------------------
	public static 	void		traceGeometricActions(MiPart obj)
		{
		traceActions(obj, MiiActionTypes.Mi_GEOMETRY_CHANGE_ACTION,
			MiDebug.Mi_LOG_PRINT_CHANGE_EVENT | MiDebug.Mi_LOG_PRINT_STACK | MiDebug.Mi_LOG_PRINT_BOUNDS);
		}
	public static 	void		traceActions(MiPart obj, int eventTypes, int options)
		{
		if (changeEventHandler == null)
			changeEventHandler = new MiDebugActionHandler();
		obj.appendActionHandler(new MiAction(changeEventHandler, eventTypes, new Integer(options)));
		}
	public static 	void		stopTracingActions(MiPart obj)
		{
		obj.removeActionHandlers(changeEventHandler);
		}
//-------------------------------------------------------------
//	MiDebug.traceModelChanges(entity, 
//	MiDebug.Mi_LOG_DUMP_TARGET | MiDebug.Mi_LOG_DUMP_SUBJECT | MiDebug.Mi_LOG_PRINT_STACK);
//-------------------------------------------------------------
	public static 	void		traceModelChanges(MiiModelEntity entity, int options)
		{
		if (modelModelChangeHandler == null)
			modelModelChangeHandler = new MiDebugModelModelChangeHandler();

		modelModelChangeHandler.append(entity, options);
		}
	public static 	void		stopTracingModelChanges(MiiModelEntity entity)
		{
		modelModelChangeHandler.remove(entity);
		}
	// Print topmost object that has an invalid layout.
/*
	public static 	void		checkForLingeringInvalidLayoutsBelow(MiPart obj, String message)
		{
		checkForLingeringInvalidLayoutsBelow(obj, obj, message);
		}
*/
	public static 	void		checkForLingeringInvalidLayoutsBelow(MiPart obj)
		{
		checkForLingeringInvalidLayoutsBelow(obj, obj, null);
		}
	protected static void		checkForLingeringInvalidLayoutsBelow(MiPart topObjChecked, MiPart obj, String message)
		{
		if ((!debug) || (!checkForLingeringInvalidLayoutsBelow))
			{
			return;
			}
		for (int i = 0; i < obj.getNumberOfParts(); ++i)
			{
			MiPart subject = obj.getPart(i);
			if ((subject.isVisible()) && (!subject.isHidden())
				&& (!subject.hasValidLayout()) 
				&& (!(subject instanceof MiEditor))
				&& (subject.getInvalidLayoutNotificationsEnabled())
				&& ((subject.getContainingWindow() == null)
				|| (!subject.getContainingWindow().hasInvalidateEditorPartLayout(subject))))
				{
				if (message == null)
					{
					message = "After validating: " + topObjChecked;
					}
				println("\n\n" + MICA_NAME + message + "\n" + "Object: " 
					+ getFullPathName(subject) + " still has invalid layout!\n");
				println("subject.isShowing(null) = " + subject.isShowing(null));
				boolean partHasMultipleContainers = false;
				MiParts parts = MiUtility.getAllParts(subject, new MiParts());
				for (int j = 0; j < parts.size(); ++j)
					{
					if (parts.elementAt(j).getNumberOfContainers() > 1)
						{
						println("Object\'s part: \"" + parts.elementAt(j) + "\" has multiple containers\n"
						+ "(" + parts.elementAt(j).getContainer(0) + " and " + parts.elementAt(j).getContainer(1) + ")\n"
						+ "one of which may be validating the part after \"" + subject + "\" validated\n"
						+ "it causing the object to then be invalidated. Try assigning a copy of the\n"
						+ "part to the object.");
						partHasMultipleContainers = true;
						break;
						}
					}
/* ***
				if (subject.getNumberOfContainers() > 1)
					{
					println("Object has multiple containers:\n"
					+ "\"" + subject.getContainer(0) + "\", and \"" + subject.getContainer(1) + "\""
					+ "(if this is desired behavior try using a MiReference as one of the containers"
					+ "otherwise try making a copy of the object).");
					partHasMultipleContainers = true;
					break;
					}
****/
				if (!partHasMultipleContainers)
					{
					println("(Sometimes this is caused by a non-Mica thread modifying graphics");
					println("at the same time Mica is validating graphics. If so, make sure the");
					println("root window of the graphics is not visible or use the");
					println("    <Some MiPart>.getRootWindow().getCanvas().getAccessLock();");
					println("method to get access to the graphics (see also freeAccessLock()))");

					println("");
					println("(Or sometimes this is caused by the Mica thread throwing an");
					println("exception in the middle of validating graphics - check your log");
					println("for recent exceptions");
					}
				//printStackTrace();
				//dump(obj);
				checkForLingeringInvalidLayoutsBelow = false;
				println("Attempting fix...");
				subject.validateLayout();
				checkForLingeringInvalidLayoutsBelow = true;
				}
			else if ((subject.hasValidLayout()) && (subject.isVisible()) && (!subject.isHidden()))
				{
				checkForLingeringInvalidLayoutsBelow(topObjChecked, subject, message);
				}
			}
		}
/*****
	public static	boolean		isShowing(MiPart subject, boolean thisPart)
		{
		if (!subject.isVisible())
			{
			println(subject + ": not visible");
			return(false);
			}
		if (subject.isHidden())
			{
			println(subject + ": hidden");
			return(false);
			}
		// FIX: needs to check all containing editors.
		for (int i = 0; i < subject.getNumberOfContainers(); ++i)
			{
			MiEditor editor = subject.getContainer(i).getContainingEditor();
			if (editor == null)
				{
				println(subject + ": container has no editor " + subject.getContainer(i));
				return(false);
				}
			if (editor.isShowing(thisPart))
				{
				println(subject + ": editor not shwoing" + editor);
				return(true);
				}
			// FIX: need to xform drawBounds if references are between here and editor...
			if (thisPart && editor.getWorldBounds().intersects(subject.getDrawBounds(new MiBounds())))
				return(true);
			}
		if ((subject instanceof MiWindow) && (((MiWindow )subject).isRootWindow()))
			return(true);

		println(subject + ": has no showing containers and is not a root window");
		return(false);
		}
*****/

	public static	String		getFullPathName(MiPart obj)
		{
		if (obj.getNumberOfContainers() > 0)
			return(getFullPathName(obj.getContainer(0)) + "->" + obj);
		return(obj.toString());
		}
	public static	void		printVerbose(String str)
		{
//		if (verboseEnabled)
			System.out.println(str);
		}
	public static	void		printValidationError(MiValueValidationError error)
		{
		Strings msg = new Strings();
		if (error.getShortDescription() != null)
			msg.addElement("Short message: " + error.getShortDescription());

		if (error.getLongErrorMessage() != null)
			msg.addElement("Long message: " + error.getLongErrorMessage());

		if (error.getHelpfulSuggestionMessage() != null)
			msg.addElement("Help message: " + error.getHelpfulSuggestionMessage());

		MiDebug.printStackTrace(msg.toString());
		}
	}

class MiDebugActionHandler implements MiiActionHandler
	{
	public			MiDebugActionHandler()
		{
		}
	public boolean		processAction(MiiAction action)
		{
		int options = ((Integer )action.getActionUserInfo()).intValue();
		if ((options & MiDebug.Mi_LOG_PRINT_CHANGE_EVENT) != 0)
			MiDebug.println("  ACTION TRACER: Object: " + action.getActionSource() + " changed");
		if ((options & MiDebug.Mi_LOG_PRINT_BOUNDS) != 0)
			MiDebug.println("  to OuterBounds = " + action.getActionSource().getBounds());
		if ((options & MiDebug.Mi_LOG_PRINT_STACK) != 0)
			{
			MiDebug.print("  at ");
			MiDebug.printStackTrace();
			}
		return(true);
		}
	}
class MiDebugModelModelChangeHandler implements MiiModelChangeHandler, MiiModelTypes
	{
	private		IntVector		options = new IntVector();
	private		MiModelEntityList	subjects = new MiModelEntityList();

	public				MiDebugModelModelChangeHandler()
		{
		}
	public		void		append(MiiModelEntity entity, int options)
		{
		subjects.addElement(entity);
		this.options.addElement(options);
		entity.appendModelChangeHandler(this, Mi_MODEL_CHANGE_COMMIT_PHASE_MASK);
		}
	public		void		remove(MiiModelEntity entity)
		{
		int index = subjects.indexOf(entity);
		options.removeElementAt(index);
		subjects.removeElementAt(index);
		entity.removeModelChangeHandler(this);
		}
	public		void		processModelChange(MiModelChangeEvent event)
		{
		if (event.hasEventType(Mi_MODEL_ADDED_EVENT_TYPE))
			{
			int index = subjects.indexOf(event.getParent());
			int options = this.options.elementAt(index);

			MiDebug.println("Adding: model child " + event.getChild() 
				+ ", to model parent: " + event.getParent());
			if ((options & MiDebug.Mi_LOG_PRINT_STACK) != 0)
				MiDebug.printStackTrace();
			if ((options & MiDebug.Mi_LOG_DUMP_TARGET) != 0)
				MiDebug.dump(event.getParent());
			if ((options & MiDebug.Mi_LOG_DUMP_SUBJECT) != 0)
				MiDebug.dump(event.getChild());
			}
		else if (event.hasEventType(Mi_MODEL_REMOVED_EVENT_TYPE))
			{
			int index = subjects.indexOf(event.getParent());
			int options = this.options.elementAt(index);

			MiDebug.println("Removing: model child " + event.getChild() 
				+ ", to model parent: " + event.getParent());
			if ((options & MiDebug.Mi_LOG_PRINT_STACK) != 0)
				MiDebug.printStackTrace();
			if ((options & MiDebug.Mi_LOG_DUMP_TARGET) != 0)
				MiDebug.dump(event.getParent());
			if ((options & MiDebug.Mi_LOG_DUMP_SUBJECT) != 0)
				MiDebug.dump(event.getChild());
			}
		}
	}

class MiDebugWidget extends MiWidget
	{
	public		void		invalidateArea(MiBounds area)
		{
		//System.out.println("invaldiateArea: " + area);
		super.invalidateArea(area);
		}
	}
interface MiiTracePartGeometryChangesWatcher
	{
	void		watch(MiPart part);
	}
class MiTracePartGeometryChangesWatcher implements MiiTracePartGeometryChangesWatcher
	{
	public		void		watch(MiPart part)
		{
		}	
	}
/*
Example usage:

MiTracePartGeometryChangesWatcher w = new MiTracePartGeometryChangesWatcher()
	{
	public void watch(MiPart part)
		{
		if (part.getWidth() == 400)
			{
			MiDebug.printStackTrace();
			MiDebug.dump(part);
			System.exit(1);
			}
		}
	};
new MiTracePartGeometryChanges(part, w);
*/
class MiTracePartGeometryChanges implements MiiActionHandler
	{
	private		MiPart		part;
	private		MiiTracePartGeometryChangesWatcher	watcher;

	public				MiTracePartGeometryChanges(
						MiPart part, MiiTracePartGeometryChangesWatcher watcher)
		{
		this.part = part;
		this.watcher = watcher;

		part.appendActionHandler(this, MiiActionTypes.Mi_GEOMETRY_CHANGE_ACTION);
		}
	public 		boolean		processAction(MiiAction action)
		{
		watcher.watch(part);
		return(true);
		}
	}


